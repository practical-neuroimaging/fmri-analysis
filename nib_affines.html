<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Applying affines with nibabel.affines.apply_affine &mdash; FMRI analysis fall 2015 0.1 documentation</title>
    
    <link rel="stylesheet" href="_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '0.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="_static/copybutton.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="top" title="FMRI analysis fall 2015 0.1 documentation" href="index.html" />
   
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9">

  </head>
  <body role="document">  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="applying-affines-with-nibabel-affines-apply-affine">
<h1>Applying affines with <code class="docutils literal"><span class="pre">nibabel.affines.apply_affine</span></code><a class="headerlink" href="#applying-affines-with-nibabel-affines-apply-affine" title="Permalink to this headline">¶</a></h1>
<p>We often want to apply an affine to an array of coordinates, where the
last axis of the array is length 3, containing the x, y and z
coordinates.</p>
<p>Nibabel uses <code class="docutils literal"><span class="pre">nibabel.affines.apply_affine</span></code> for this.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy.linalg</span> <span class="kn">as</span> <span class="nn">npl</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">nibabel</span> <span class="kn">as</span> <span class="nn">nib</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">points</span>
<span class="go">array([[ 0,  1,  2],</span>
<span class="go">       [ 2,  2,  4],</span>
<span class="go">       [ 3, -2,  1],</span>
<span class="go">       [ 5,  3,  1]])</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">zooms_plus_translations</span> <span class="o">=</span> <span class="n">nib</span><span class="o">.</span><span class="n">affines</span><span class="o">.</span><span class="n">from_matvec</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]),</span> <span class="p">[</span><span class="mi">11</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">13</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">zooms_plus_translations</span>
<span class="go">array([[ 3,  0,  0, 11],</span>
<span class="go">       [ 0,  4,  0, 12],</span>
<span class="go">       [ 0,  0,  5, 13],</span>
<span class="go">       [ 0,  0,  0,  1]])</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">nib</span><span class="o">.</span><span class="n">affines</span><span class="o">.</span><span class="n">apply_affine</span><span class="p">(</span><span class="n">zooms_plus_translations</span><span class="p">,</span> <span class="n">points</span><span class="p">)</span>
<span class="go">array([[11, 16, 23],</span>
<span class="go">       [17, 20, 33],</span>
<span class="go">       [20,  4, 18],</span>
<span class="go">       [26, 24, 18]])</span>
</pre></div>
</div>
<p>Of course, this is the same as:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">mat</span><span class="p">,</span> <span class="n">vec</span> <span class="o">=</span> <span class="n">nib</span><span class="o">.</span><span class="n">affines</span><span class="o">.</span><span class="n">to_matvec</span><span class="p">(</span><span class="n">zooms_plus_translations</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mat</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">points</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">T</span> <span class="o">+</span> <span class="n">vec</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="go">array([[11, 16, 23],</span>
<span class="go">       [17, 20, 33],</span>
<span class="go">       [20,  4, 18],</span>
<span class="go">       [26, 24, 18]])</span>
</pre></div>
</div>
<p>The advantage of <code class="docutils literal"><span class="pre">nib.affines.apply_affine</span></code> is that it can deal with
arrays of more than two dimensions, and it transposes the transformation
matrices for you to apply the transforms correctly.</p>
<p>A typical use is when applying extra affine transformations to a X by Y
by Z by 3 array of coordinates.</p>
<div class="section" id="affine-transform-and-the-implied-coordinate-grid">
<h2><code class="docutils literal"><span class="pre">affine_transform</span></code> and the implied coordinate grid<a class="headerlink" href="#affine-transform-and-the-implied-coordinate-grid" title="Permalink to this headline">¶</a></h2>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">scipy.ndimage</span> <span class="kn">import</span> <span class="n">affine_transform</span><span class="p">,</span> <span class="n">map_coordinates</span>
</pre></div>
</div>
<p>So far we have done all our image resampling with
<code class="docutils literal"><span class="pre">scipy.ndimage.affine_transform</span></code>.</p>
<p><code class="docutils literal"><span class="pre">affine_transform</span></code> accepts:</p>
<ul class="simple">
<li>an array to resample from (<code class="docutils literal"><span class="pre">input</span></code>);</li>
<li>the <code class="docutils literal"><span class="pre">mat</span></code> part of an affine;</li>
<li>the <code class="docutils literal"><span class="pre">vec</span></code> (translation) part of an affine;</li>
<li>an optional <code class="docutils literal"><span class="pre">output_shape</span></code> (defaulting to <code class="docutils literal"><span class="pre">input.shape</span></code>).</li>
</ul>
<p><code class="docutils literal"><span class="pre">affine_transform</span></code> then generates all the voxel coordinates <em>implied
by</em> the <code class="docutils literal"><span class="pre">output_shape</span></code>, and transforms them with the <code class="docutils literal"><span class="pre">mat</span></code> and
<code class="docutils literal"><span class="pre">vec</span></code> transforms to get a new set of coordinates <code class="docutils literal"><span class="pre">C</span></code>. It then
samples the <code class="docutils literal"><span class="pre">input</span></code> array at the coordinates given by <code class="docutils literal"><span class="pre">C</span></code> to
generate the output array.</p>
</div>
<div class="section" id="making-coordinate-arrays-with-meshgrid">
<h2>Making coordinate arrays with meshgrid<a class="headerlink" href="#making-coordinate-arrays-with-meshgrid" title="Permalink to this headline">¶</a></h2>
<p><code class="docutils literal"><span class="pre">affine_transform</span></code> works by using voxel coordinate implied by the
<code class="docutils literal"><span class="pre">output_shape</span></code>, and transforming those.</p>
<p><code class="docutils literal"><span class="pre">meshgrid</span></code> is a way of making an actual coordinate grid.</p>
<p>As we will see soon, this is particularly useful when we want to use the
more general form of image resampling in
<code class="docutils literal"><span class="pre">scipy.ndimage.map_coordinates</span></code>.</p>
<p>If we have some shape - say <code class="docutils literal"><span class="pre">output_shape</span></code> - then this implies a set
of coordinates. Let&#8217;s say <code class="docutils literal"><span class="pre">output_shape</span> <span class="pre">=</span> <span class="pre">(5,</span> <span class="pre">4)</span></code> - implying a 2D
array.</p>
<p>The implied coordinate grid will therefore have one coordinate for each
pixel (2D voxel) in the (5, 4) array.</p>
<p>Because this array is 2D, there are two coordinate values for each
pixel. For example, the coordinate of the first element in the array is
(0, 0). We can make these i- and j- coordinates with <code class="docutils literal"><span class="pre">meshgrid</span></code>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">i_coords</span><span class="p">,</span> <span class="n">j_coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">),</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">),</span> <span class="n">indexing</span><span class="o">=</span><span class="s">&#39;ij&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="s">&#39;i_coords&#39;</span><span class="p">,</span> <span class="n">i_coords</span><span class="p">)</span>
<span class="go">i_coords [[0 0 0 0]</span>
<span class="go"> [1 1 1 1]</span>
<span class="go"> [2 2 2 2]</span>
<span class="go"> [3 3 3 3]</span>
<span class="go"> [4 4 4 4]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="s">&#39;j_coords&#39;</span><span class="p">,</span> <span class="n">j_coords</span><span class="p">)</span>
<span class="go">j_coords [[0 1 2 3]</span>
<span class="go"> [0 1 2 3]</span>
<span class="go"> [0 1 2 3]</span>
<span class="go"> [0 1 2 3]</span>
<span class="go"> [0 1 2 3]]</span>
</pre></div>
</div>
<p>We can make this into a shape (2, 5, 4) array where the first axis
contains the (i, j) coordinate.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">coordinate_grid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">i_coords</span><span class="p">,</span> <span class="n">j_coords</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">coordinate_grid</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(2, 5, 4)</span>
</pre></div>
</div>
<p>Because we have not done any transformation on the coordinate, the i, j
coordinate will be the same as the index we use to get the i, j
coordinate:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">coordinate_grid</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
<span class="go">[0 0]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">coordinate_grid</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
<span class="go">[1 0]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">coordinate_grid</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="go">[0 1]</span>
</pre></div>
</div>
<p>This then is the coordinate grid implied by a shape of (5, 4).</p>
<p>Now imagine I wanted to do a transformation on these coordinates. Say I
wanted to add 2 the first (i) coordinate:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">coordinate_grid</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">+=</span> <span class="mi">2</span>
</pre></div>
</div>
<p>Now my coordinate grid expresses a <em>mapping</em> between a given
(<span class="math">\(i, j\)</span>) coordinate, and the new coordinate (<span class="math">\(i', j'\)</span>. I
look up the new coordinate using the <span class="math">\(i, j\)</span> index into the
coordinate grid:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">coordinate_grid</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>  <span class="c"># look up new coordinate for (0, 0)</span>
<span class="go">[2 0]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">coordinate_grid</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>  <span class="c"># look up new coordinate for (1, 0)</span>
<span class="go">[3 0]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">coordinate_grid</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>  <span class="c"># look up new coordinate for (0, 1)</span>
<span class="go">[2 1]</span>
</pre></div>
</div>
<p>This means we can use these coordinate grids as a <em>mapping</em> from an
input set of coordinates to an output set of coordinates, for each pixel
/ voxel.</p>
<p>As you can imagine, meshgrid extends simply to three dimensions or more:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">output_shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">i_coords</span><span class="p">,</span> <span class="n">j_coords</span><span class="p">,</span> <span class="n">k_coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">output_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="nb">range</span><span class="p">(</span><span class="n">output_shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="nb">range</span><span class="p">(</span><span class="n">output_shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]),</span>
<span class="gp">... </span>                                           <span class="n">indexing</span><span class="o">=</span><span class="s">&#39;ij&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">coordinate_grid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">i_coords</span><span class="p">,</span> <span class="n">j_coords</span><span class="p">,</span> <span class="n">k_coords</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">coordinate_grid</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(3, 5, 6, 7)</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">coordinate_grid</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
<span class="go">[0 0 0]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">coordinate_grid</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
<span class="go">[1 0 0]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">coordinate_grid</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
<span class="go">[0 1 0]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">coordinate_grid</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="go">[0 0 1]</span>
</pre></div>
</div>
</div>
<div class="section" id="general-resampling-between-images-with-scipy-ndimage-map-coordinates">
<h2>General resampling between images with <code class="docutils literal"><span class="pre">scipy.ndimage.map_coordinates</span></code><a class="headerlink" href="#general-resampling-between-images-with-scipy-ndimage-map-coordinates" title="Permalink to this headline">¶</a></h2>
<p><code class="docutils literal"><span class="pre">map_coordinates</span></code> is the more general of resampling from images with
coordinates.</p>
<p>Instead of using the <em>implied</em> coordinate grid, we pass in an actual
coordinate array.</p>
<p>This means that we can resample using coordinate transformations that
can&#8217;t be expressed as an affine, such as complex non-linear
transformations. <code class="docutils literal"><span class="pre">map_coordinates</span></code> accepts:</p>
<ul class="simple">
<li>array array to resample from (<code class="docutils literal"><span class="pre">input</span></code>);</li>
<li>The <code class="docutils literal"><span class="pre">C</span></code> array shape (3,) + output_shape giving the voxel
coordinates at which to sample <code class="docutils literal"><span class="pre">input</span></code>.</li>
</ul>
<p><code class="docutils literal"><span class="pre">map_coordinates</span></code> then makes an empty array shape <code class="docutils literal"><span class="pre">D</span></code> where
<code class="docutils literal"><span class="pre">D</span> <span class="pre">=</span> <span class="pre">C.shape[1:]</span></code>. For every index <code class="docutils literal"><span class="pre">i,</span> <span class="pre">j,</span> <span class="pre">k</span></code> it:</p>
<ul class="simple">
<li>Gets the 3-length vector <code class="docutils literal"><span class="pre">coord</span> <span class="pre">=</span> <span class="pre">C[:,</span> <span class="pre">i,</span> <span class="pre">j,</span> <span class="pre">k]</span></code> giving the voxel
coordinate in <code class="docutils literal"><span class="pre">input</span></code>;</li>
<li>Samples <code class="docutils literal"><span class="pre">input</span></code> at coordinates <code class="docutils literal"><span class="pre">coord</span></code> to give value <code class="docutils literal"><span class="pre">v</span></code>;</li>
<li>Inserts <code class="docutils literal"><span class="pre">v</span></code> into <code class="docutils literal"><span class="pre">D</span></code> with <code class="docutils literal"><span class="pre">D[i,</span> <span class="pre">j,</span> <span class="pre">k]</span> <span class="pre">=</span> <span class="pre">v</span></code>.</li>
</ul>
<p>This might be clearer with an example. Let&#8217;s resample a structural to a
functional like we did last week (see
<code class="docutils literal"><span class="pre">day10/resampling_with_affines_solutions.ipynb</span></code>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">nibabel</span> <span class="kn">as</span> <span class="nn">nib</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bold_img</span> <span class="o">=</span> <span class="n">nib</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s">&#39;ds114_sub009_t2r1.nii&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mean_bold_data</span> <span class="o">=</span> <span class="n">bold_img</span><span class="o">.</span><span class="n">get_data</span><span class="p">()</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">structural_img</span> <span class="o">=</span> <span class="n">nib</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s">&#39;ds114_sub009_highres.nii&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">structural_data</span> <span class="o">=</span> <span class="n">structural_img</span><span class="o">.</span><span class="n">get_data</span><span class="p">()</span>
</pre></div>
</div>
<p>We now now the transformation to go from voxels in the structural to
voxels in the (mean) functional:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">struct_vox2mean_vox</span> <span class="o">=</span> <span class="n">npl</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">bold_img</span><span class="o">.</span><span class="n">affine</span><span class="p">)</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">structural_img</span><span class="o">.</span><span class="n">affine</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">struct_vox2mean_vox</span>
<span class="go">array([[ -0.2497,   0.0151,  -0.0027,  63.5174],</span>
<span class="go">       [  0.0115,   0.3242,   0.0137,   1.1053],</span>
<span class="go">       [ -0.0034,  -0.0176,   0.2496, -27.7359],</span>
<span class="go">       [  0.    ,   0.    ,   0.    ,   1.    ]])</span>
</pre></div>
</div>
<p>Sure enough, if we use this affine to resample the functional image, we
get a functional image with the same voxel sizes and positions as the
structural image:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="c"># Resample using affine_transform</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mat</span><span class="p">,</span> <span class="n">vec</span> <span class="o">=</span> <span class="n">nib</span><span class="o">.</span><span class="n">affines</span><span class="o">.</span><span class="n">to_matvec</span><span class="p">(</span><span class="n">struct_vox2mean_vox</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">resampled_mean</span> <span class="o">=</span> <span class="n">affine_transform</span><span class="p">(</span><span class="n">mean_bold_data</span><span class="p">,</span> <span class="n">mat</span><span class="p">,</span> <span class="n">vec</span><span class="p">,</span> <span class="n">output_shape</span><span class="o">=</span><span class="n">structural_data</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="c"># Show resampled data</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fig</span><span class="p">,</span> <span class="n">axes</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">resampled_mean</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">150</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">structural_data</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">150</span><span class="p">])</span>
<span class="gp">...</span>
</pre></div>
</div>
<p>(<a class="reference external" href=".//nib_affines-18.png">png</a>, <a class="reference external" href=".//nib_affines-18.hires.png">hires.png</a>, <a class="reference external" href=".//nib_affines-18.pdf">pdf</a>)</p>
<div class="figure">
<img alt="_images/nib_affines-18.png" src="_images/nib_affines-18.png" />
</div>
<p>We get the exact same effect with <code class="docutils literal"><span class="pre">map_coordinates</span></code> if we create the
voxel coordinates ourselves, and apply the transform to them:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="c"># Get the I, J, K coordinates implied by the structural data array shape</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">I</span><span class="p">,</span> <span class="n">J</span><span class="p">,</span> <span class="n">K</span> <span class="o">=</span> <span class="n">structural_data</span><span class="o">.</span><span class="n">shape</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">i_vals</span><span class="p">,</span> <span class="n">j_vals</span><span class="p">,</span> <span class="n">k_vals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">I</span><span class="p">),</span> <span class="nb">range</span><span class="p">(</span><span class="n">J</span><span class="p">),</span> <span class="nb">range</span><span class="p">(</span><span class="n">K</span><span class="p">),</span> <span class="n">indexing</span><span class="o">=</span><span class="s">&#39;ij&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">in_vox_coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">i_vals</span><span class="p">,</span> <span class="n">j_vals</span><span class="p">,</span> <span class="n">k_vals</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">in_vox_coords</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(3, 256, 156, 256)</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">in_vox_coords</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
<span class="go">array([0, 0, 0])</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">in_vox_coords</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
<span class="go">array([1, 0, 0])</span>
</pre></div>
</div>
<p>Transform using affine:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">coords_last</span> <span class="o">=</span> <span class="n">in_vox_coords</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mean_vox_coords</span> <span class="o">=</span> <span class="n">nib</span><span class="o">.</span><span class="n">affines</span><span class="o">.</span><span class="n">apply_affine</span><span class="p">(</span><span class="n">struct_vox2mean_vox</span><span class="p">,</span> <span class="n">coords_last</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">coords_first_again</span> <span class="o">=</span> <span class="n">mean_vox_coords</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
<p>Use this with <code class="docutils literal"><span class="pre">map_coordinates</span></code> to get the same result as we got for
<code class="docutils literal"><span class="pre">affine_transform</span></code>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="c"># Resample using map_coordinates</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">resampled_mean_again</span> <span class="o">=</span> <span class="n">map_coordinates</span><span class="p">(</span><span class="n">mean_bold_data</span><span class="p">,</span> <span class="n">coords_first_again</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="c"># Show resampled data</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fig</span><span class="p">,</span> <span class="n">axes</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">resampled_mean_again</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">150</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">structural_data</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">150</span><span class="p">])</span>
<span class="gp">...</span>
</pre></div>
</div>
<p>(<a class="reference external" href=".//nib_affines-24.png">png</a>, <a class="reference external" href=".//nib_affines-24.hires.png">hires.png</a>, <a class="reference external" href=".//nib_affines-24.pdf">pdf</a>)</p>
<div class="figure">
<img alt="_images/nib_affines-24.png" src="_images/nib_affines-24.png" />
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="index.html">FMRI analysis fall 2015</a></h1>



<p class="blurb">Fall 2015</p>




<h3>Navigation</h3>
<ul>
<li class="toctree-l1"><a class="reference internal" href="day2_homework.html">Homework for day 2 of analysis</a></li>
<li class="toctree-l1"><a class="reference internal" href="day3.html">Day 3 of FMRI analysis</a></li>
<li class="toctree-l1"><a class="reference internal" href="day3_homework.html">Homework for day 3 of analysis</a></li>
</ul>


<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2009-2015, Matthew Brett, JB Poline.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.3.1</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.6</a>
      
      |
      <a href="_sources/nib_affines.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>